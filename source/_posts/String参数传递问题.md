title: String参数传递问题
categories: Java
tags:
  - Java
  - 面试
date: 2016-02-22 16:17:35
---
一道在Java面试中经常会碰到的面试题
```Java
public class StringTest{
    public static void main(String[] args){
        String str = "Test";

        changeStr(str);

        System.out.println(str);

    }

    private static void changeStr(String old){
        //String是final类型，下面的两句其实都是生成了另外一个String对象，old存放的地址值变化了
        old = old + "-change";
        //old = old.replace("s","x");
    }
}
```
输出结果：
> Test


先把几个知识点列出来：

> 1：按值传递是什么
指的是在方法调用时，传递的参数是按值的拷贝传递
按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了。

> 2：按引用传递是什么
指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。
按引用传递的重要特点：传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。

总结：
> 值传递：
**当基本类型作为参数传入方法时，无论该参数在方法内怎样被改变，外部的变量原型总是不变的**。

> 引用传递：
**当方法传入的参数为引用数据类型(类、接口、数组)时， 方法改变参数变量的同时变量原型也会随之改变**。


其实，要想真正理解一个类或者一个API/框架的最直接的方法就是看源码，现在我看String类的构造函数
```Java
public String() {
       this.value = new char[0];
   }

   public String(String original) {
       this.value = original.value;
       this.hash = original.hash;
   }
  ```

   从中不难发现String实际是通过`char[]`来储存的。
   String就相当于是char[]的包装类。包装类的特质之一就是在对其值进行操作时会体现出其对应的基本类型的性质。

说明
> （1）：“在Java里面参数传递都是按值传递”这句话的意思是：
按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。

面试题看不懂可以参考这篇文章：
[java参数传递（超经典）](http://blog.sina.com.cn/s/blog_4b622a8e0100c1bo.html)
<<<<<<< HEAD
[java中方法的参数传递机制](http://www.cnblogs.com/lixiaolun/p/4311863.html)
=======
>>>>>>> ac08ee1f28d47f6b8673c9a0d27b15a38fae66be


`另一种解读：`

> 这个结果为什么是`Test`呢？经过查阅资料，原来是String虽然以对象的形式存在，但仍认为是基本数据类型，
 就像Integer、Double那样，虽然是基本类型的包装类，但仍然认为是基本数据类型。
既然认为是基本数据类型，因此无论在方法中如何操作，都不会影响到外界。

> 其实，换个角度，也可以发现这样是错误的。
首先，大家都知道字符串是不可改变的，简单理解即可，不做深入讨论。

> 当我们把字符串当成参数传入方法时，传递的是值，是一个指针，这个指针指向了堆区的真实字符串，
因此在方法中可以读到这个字符串，但是仅仅是能读到而已，当我们试图做如下操作时：
`str = str.replace(“a”,”b”);`
后边的str中保存的是原来的指针，的确是可以读到原来的字符串，然后执行替换操作，但是替换操作执行时，
绝对不可能去修改原来的字符串，因为字符串是不可变的，因此只能是**在堆区产生一个新的字符串，
然后把新字符串的地址(指针)赋给str**。

> *此时str中保存的已经不再是原来的指针，因此读出的内容发生了变化，但不代表原来指针指向的内容发生了变化*。


另外，顺便再补充一个知识点。
关于`Integer i = 1;`和`Integer i = new Integer(1);`的区别。

> `Integer i = 1;`
会直接从常量池中找到1，然后把地址赋给i，这样充分利用常量池，节省内存，注意除了字符串，
其他类型的常量池都是有范围的，超范围了失效。

> `Integer i = new Integer(1);`
这样写，写多少次，就在内存中创建多少个对象，每个对象里都保存了一个数字1，
因此这样是极其浪费内存的，不推荐使用。
